\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_baked_vector_path}{xu\+::\+Baked\+Vector\+Path}} }{\pageref{structxu_1_1_baked_vector_path}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_bounds2}{xu\+::\+Bounds2$<$ T $>$}} }{\pageref{structxu_1_1_bounds2}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_box_stack}{xu\+::\+Box\+Stack}} }{\pageref{classxu_1_1_box_stack}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_button}{xu\+::\+Button}} }{\pageref{classxu_1_1_button}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_cmd_draw_triangles}{xu\+::\+Cmd\+Draw\+Triangles}} \\*Structure describing a Draw\+Triangles command }{\pageref{structxu_1_1_cmd_draw_triangles}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_cmd_merge_layer}{xu\+::\+Cmd\+Merge\+Layer}} \\*Structure describing a Merge\+Layer command }{\pageref{structxu_1_1_cmd_merge_layer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_cmd_new_layer}{xu\+::\+Cmd\+New\+Layer}} \\*Structure describing a New\+Layer command }{\pageref{structxu_1_1_cmd_new_layer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_color}{xu\+::\+Color}} \\*Simple R\+G\+BA 888+F (3x8-\/bit R\+GB components, 1x float alpha) color type }{\pageref{structxu_1_1_color}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_command_list}{xu\+::\+Command\+List}} \\*Stores a list of drawing commands. Each OS window gets its own command list }{\pageref{classxu_1_1_command_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_context}{xu\+::\+Context}} \\*Core context class of the Xu library }{\pageref{classxu_1_1_context}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_cursor_button_event}{xu\+::\+Cursor\+Button\+Event}} }{\pageref{structxu_1_1_cursor_button_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_cursor_move_event}{xu\+::\+Cursor\+Move\+Event}} }{\pageref{structxu_1_1_cursor_move_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1quick_1_1_darcula_theme}{xu\+::quick\+::\+Darcula\+Theme}} }{\pageref{classxu_1_1quick_1_1_darcula_theme}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_draw_command}{xu\+::\+Draw\+Command}} \\*Structure describing a draw command }{\pageref{structxu_1_1_draw_command}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_input_state}{xu\+::\+Input\+State}} }{\pageref{classxu_1_1_input_state}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_command_list_1_1_iterator}{xu\+::\+Command\+List\+::\+Iterator}} \\*\mbox{\hyperlink{classxu_1_1_command_list_1_1_iterator}{Iterator}} that can iterate over the drawcommands in the \mbox{\hyperlink{classxu_1_1_command_list}{Command\+List}}, keeping track of things like the current layer, vertex offset, etc. This class satisfies the Bidirectional\+Iterator concept }{\pageref{classxu_1_1_command_list_1_1_iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{unionxu_1_1_layer_filter_info}{xu\+::\+Layer\+Filter\+Info}} }{\pageref{unionxu_1_1_layer_filter_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_layout}{xu\+::\+Layout}} \\*Minimal layout interface which is capable of selecting a minimum fitting size and changing the geometry of its items when invalidated. The implementor of this interface is responsible for storing children via \mbox{\hyperlink{classxu_1_1_layout_ab3fb38fbb7f64cc87c19b08f3b537d33}{Layout\+::\+Insert\+Item}} and \mbox{\hyperlink{classxu_1_1_layout_ab067e1cf54c2c8625acd1c2458375393}{Layout\+::\+Num\+Items}} }{\pageref{classxu_1_1_layout}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_layout_item}{xu\+::\+Layout\+Item}} \\*Mediating class which acts as a proxy for anything that can be placed in a layout (namely other layouts and widgets) }{\pageref{classxu_1_1_layout_item}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_wsi_interface_1_1_new_window_result}{xu\+::\+Wsi\+Interface\+::\+New\+Window\+Result}} }{\pageref{structxu_1_1_wsi_interface_1_1_new_window_result}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_paint_info}{xu\+::\+Paint\+Info}} }{\pageref{structxu_1_1_paint_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_parameters}{xu\+::\+Parameters}} }{\pageref{structxu_1_1_parameters}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_rect2}{xu\+::\+Rect2$<$ T $>$}} }{\pageref{structxu_1_1_rect2}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_render_data}{xu\+::\+Render\+Data}} \\*Main class that stores all data needed to render the full UI. Maintains a \mbox{\hyperlink{classxu_1_1_command_list}{xu\+::\+Command\+List}} for each OS window }{\pageref{classxu_1_1_render_data}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_signal}{xu\+::\+Signal$<$ Ts $>$}} \\*Signal/slot type which emits events with variadic template arguments (hence the variadic templates). Slots can be connected with member function pointers or regular function pointers }{\pageref{classxu_1_1_signal}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_surface}{xu\+::\+Surface}} \\*Represents a surface for widgets to paint their visual representation on }{\pageref{classxu_1_1_surface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_theme}{xu\+::\+Theme}} }{\pageref{classxu_1_1_theme}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_unique_slot}{xu\+::\+Unique\+Slot$<$ X $>$}} \\*R\+A\+I\+I-\/based slot object which will automatically call Connect and Disconnect on construction and destruction, respectively. This prevents dangling slots since \mbox{\hyperlink{classxu_1_1_signal}{Signal}} is not aware that a member function pointer instance is no longer valid and will wrongly continue to blindly invoke it }{\pageref{classxu_1_1_unique_slot}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_unique_slot_3_01_f_01_4}{xu\+::\+Unique\+Slot$<$ F $>$}} }{\pageref{classxu_1_1_unique_slot_3_01_f_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_vector2}{xu\+::\+Vector2$<$ T $>$}} }{\pageref{structxu_1_1_vector2}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_vector_path}{xu\+::\+Vector\+Path}} }{\pageref{structxu_1_1_vector_path}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_vector_path_event}{xu\+::\+Vector\+Path\+Event}} }{\pageref{structxu_1_1_vector_path_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_vertex}{xu\+::\+Vertex}} \\*One vertex used in the draw commands. This structure is guaranteed to be a P\+OD, and is memcpy()\textquotesingle{}able into vertex buffers }{\pageref{structxu_1_1_vertex}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_widget}{xu\+::\+Widget}} \\*Core widget class of the library. All widgets must derive from this class }{\pageref{classxu_1_1_widget}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_widget_ptr}{xu\+::\+Widget\+Ptr$<$ T $>$}} \\*Special immutable widget pointer wrapper which can nullify the pointer before the widget is destroyed. This reasoning behind this is that there is no way to know that a widget being pointed to (via Widget$\ast$) has been destroyed. This simple wrapper class will listen for the event emitted by the widget in its destructor and nullify the stored pointer. Therefore, when the stored pointer is null, it can be checked for widget destroyal state (otherwise not possible with a raw widget pointer) }{\pageref{structxu_1_1_widget_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_window_cursor_enter_event}{xu\+::\+Window\+Cursor\+Enter\+Event}} }{\pageref{structxu_1_1_window_cursor_enter_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_window_move_event}{xu\+::\+Window\+Move\+Event}} \\*Struct used to describe a window move event }{\pageref{structxu_1_1_window_move_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_window_resize_event}{xu\+::\+Window\+Resize\+Event}} \\*Struct used to describe a window resize event }{\pageref{structxu_1_1_window_resize_event}}{}
\item\contentsline{section}{\mbox{\hyperlink{classxu_1_1_wsi_interface}{xu\+::\+Wsi\+Interface}} }{\pageref{classxu_1_1_wsi_interface}}{}
\item\contentsline{section}{\mbox{\hyperlink{unionxu_1_1_vector_path_event_1_1_x_u___a_p_i}{xu\+::\+Vector\+Path\+Event\+::\+X\+U\+\_\+\+A\+PI}} }{\pageref{unionxu_1_1_vector_path_event_1_1_x_u___a_p_i}}{}
\item\contentsline{section}{\mbox{\hyperlink{structxu_1_1_vector_path_event_1_1_x_u___a_p_i_1_1_x_u___a_p_i}{xu\+::\+Vector\+Path\+Event\+::\+X\+U\+\_\+\+A\+P\+I\+::\+X\+U\+\_\+\+A\+PI}} }{\pageref{structxu_1_1_vector_path_event_1_1_x_u___a_p_i_1_1_x_u___a_p_i}}{}
\end{DoxyCompactList}
